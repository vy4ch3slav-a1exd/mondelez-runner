<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
<title>Mondelez Runner ‚Äî 3D ULTRA</title>
<meta name="theme-color" content="#0b0b12">
<style>
  :root { --bg:#0b0b12; --ui:#ffffff; --accent:#7a4bd4; --mint:#00ff95; --blue:#2b7bd4; }
  * { box-sizing: border-box; }
  html, body { margin:0; height:100%; background:var(--bg); overflow:hidden; }
  #hud { position:fixed; inset:0; pointer-events:none; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial; }
  .hud { position:absolute; left:10px; top:8px; color:#fff; text-shadow:0 3px 12px rgba(0,0,0,.6); font-weight:800; }
  .hud .line { font-size:12px; opacity:.95; letter-spacing:.2px; }
  .hud .big { font-size:16px; margin-bottom:2px; }
  .btns { position:absolute; right:10px; top:8px; display:flex; gap:8px; }
  .btn { pointer-events:auto; border:none; border-radius:10px; padding:9px 14px; background:#2b225a; color:#fff; font-weight:800; cursor:pointer; box-shadow:0 8px 26px rgba(0,0,0,.25); }
  .btn.sec { background:var(--blue); }
  .toast { position:absolute; left:50%; transform:translateX(-50%); bottom:9vh; background:rgba(20,20,35,.9);
           color:#d9d9ff; padding:10px 14px; border:1px solid rgba(122,75,212,.6); border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.4); opacity:0; transition:opacity .25s, transform .25s; pointer-events:none; white-space:nowrap; }
  .toast.show { opacity:1; transform:translate(-50%, -8px); }
  .banner { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .card { pointer-events:auto; max-width:min(820px, 94vw); background:rgba(255,255,255,.97); border:3px solid var(--accent); border-radius:18px; padding:18px 20px; color:#2b225a; text-align:center; box-shadow:0 18px 60px rgba(0,0,0,.35); }
  .hidden { display:none; }
  .dev { font-family: ui-monospace, Menlo, Consolas, monospace; color:var(--mint); text-shadow:0 0 8px rgba(0,255,149,.35); font-size:clamp(13px,2.2vw,18px); margin:6px 0 12px; }
  .start-title { font-size: clamp(22px, 4vw, 36px); margin: 6px 0 8px; }
  .mini { opacity:.8; font-size:clamp(12px,2vw,14px); }
  .start-actions { display:flex; justify-content:center; gap:10px; margin-top:12px; }
  .btnlg { pointer-events:auto; border:none; border-radius:12px; padding:12px 20px; background:#2b225a; color:#fff; font-weight:900; cursor:pointer; box-shadow:0 10px 30px rgba(0,0,0,.3); }
  .countdown { position:absolute; left:50%; top:38%; transform:translate(-50%,-50%); color:#fff; font-weight:900; font-size:12vh; text-shadow:0 10px 50px rgba(0,0,0,.35); pointer-events:none; }
  .touchhint { position:absolute; left:50%; bottom:24px; transform:translateX(-50%); color:#9fd; background:rgba(0,0,0,.35); padding:6px 10px; border-radius:10px; font:12px/1.2 ui-monospace, Menlo, Consolas, monospace; }
</style>
</head>
<body>
<div id="hud">
  <div class="hud">
    <div class="line big" id="levelLabel">–£—Ä–æ–≤–µ–Ω—å: ‚Äî</div>
    <div class="line" id="scoreLabel">–û—á–∫–∏ (–∫—Ä–æ—à–∫–∏): 0</div>
    <div class="line" id="bestLabel">–†–µ–∫–æ—Ä–¥: 0</div>
    <div class="line" id="statusLabel"></div>
  </div>
  <div class="btns">
    <button class="btn" id="restartBtn">–ó–∞–Ω–æ–≤–æ</button>
    <button class="btn sec" id="pauseBtn">–ü–∞—É–∑–∞</button>
  </div>
  <div class="toast" id="toast">–¢–µ–∫—Å—Ç</div>
  <div class="countdown hidden" id="count">3</div>
  <div class="touchhint" id="hint">–¢–∞–ø ‚Äî –ø—Ä—ã–∂–æ–∫, –≤—Ç–æ—Ä–æ–π —Ç–∞–ø ‚Äî –¥–≤–æ–π–Ω–æ–π –ø—Ä—ã–∂–æ–∫</div>

  <div class="banner" id="startBanner" aria-modal="true" role="dialog">
    <div class="card">
      <div style="font-size:42px;margin-bottom:6px;">üç™‚ö°üõí</div>
      <h1 class="start-title">Mondelez Runner ‚Äî 3D ULTRA</h1>
      <div class="dev">Œõl—î–∫—ÅŒ±ndr R√∏d—ñonœÉv ‚Ä¢ Œõl—îx—îy Bl—ñnœÉv</div>
      <div class="mini">–°–æ–±–∏—Ä–∞–π –∫—Ä–æ—à–∫–∏, —É–≤–æ—Ä–∞—á–∏–≤–∞–π—Å—è –æ—Ç OOS/ERP, –ª–æ–≤–∏ ¬´–ø—Ä–µ–ø–∞–∫¬ª (—â–∏—Ç) –∏ ¬´–¥–æ–ø—Å–∫–∏–¥–∫—É¬ª (—É—Å–∫–æ—Ä–µ–Ω–∏–µ). –î–≤–æ–π–Ω–æ–π –ø—Ä—ã–∂–æ–∫: –≤—Ç–æ—Ä–æ–π —Ç–∞–ø ‚Äî –≤ –≤–æ–∑–¥—É—Ö–µ. –ï—Å—Ç—å ¬´coyote time¬ª –∏ ¬´jump buffer¬ª ‚Äî –ø—Ä—ã–∂–æ–∫ –æ—â—É—â–∞–µ—Ç—Å—è –∫–∞–∫ –≤ –±–æ–ª—å—à–∏—Ö –∏–≥—Ä–∞—Ö.</div>
      <div class="start-actions"><button class="btnlg" id="startBtn">START</button></div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script>
(function(){
  'use strict';
  const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints>0;

  // THREE setup
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: 'high-performance' });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  document.body.prepend(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b12);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.set(0, 2.1, 6);

  // Lights
  const hemi = new THREE.HemisphereLight(0x88bbff, 0x403020, 0.8);
  const dir = new THREE.DirectionalLight(0xffffff, 1.2);
  dir.position.set(4,6,3);
  dir.castShadow = true;
  dir.shadow.mapSize.set(1024,1024);
  scene.add(hemi, dir);

  // Ground (endless stripes)
  const groundGeo = new THREE.PlaneGeometry(40, 200, 1, 1);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a2740, metalness:0.1, roughness:0.8 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.z = -60;
  ground.receiveShadow = true;
  scene.add(ground);

  // Sky gradient
  const skyGeo = new THREE.SphereGeometry(60, 32, 16);
  const skyMat = new THREE.MeshBasicMaterial({ color: 0x111527, side: THREE.BackSide });
  const sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);

  // Oreo player (double biscuit with cream)
  function createOreo(){
    const g1 = new THREE.CylinderGeometry(0.45,0.45,0.18, 48);
    const g2 = new THREE.CylinderGeometry(0.43,0.43,0.08, 48);
    const matBrown = new THREE.MeshStandardMaterial({ color: 0x3b2f2f, metalness:0.3, roughness:0.6 });
    const matCream = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness:0.05, roughness:0.4 });
    const top = new THREE.Mesh(g1, matBrown);
    const bot = new THREE.Mesh(g1, matBrown);
    const cream = new THREE.Mesh(g2, matCream);
    top.castShadow=bot.castShadow=cream.castShadow=true;
    top.position.y = 0.13; bot.position.y = -0.13; cream.position.y = 0;
    const group = new THREE.Group();
    group.add(top, bot, cream);

    // Eyes
    const eyeGeo = new THREE.SphereGeometry(0.035, 16, 12);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness:0.2, roughness:0.3 });
    const e1 = new THREE.Mesh(eyeGeo, eyeMat);
    const e2 = new THREE.Mesh(eyeGeo, eyeMat);
    e1.position.set(-0.12, 0.06, 0.44);
    e2.position.set( 0.12, 0.06, 0.44);
    group.add(e1,e2);

    group.traverse(o=>o.castShadow=true);
    return group;
  }

  const player = createOreo();
  player.position.set(0, 0.6, 0);
  scene.add(player);

  // Obstacles & goodies
  const obstacles = [];
  const goodies = []; // {type, mesh}
  const crumbs = [];  // pickups small

  function spawnObstacle(){
    const type = Math.random()<0.5? 'cube' : (Math.random()<0.5?'fall':'wall');
    let mesh;
    if(type==='cube'){
      const s = 0.5 + Math.random()*0.3;
      mesh = new THREE.Mesh(new THREE.BoxGeometry(s,s,s), new THREE.MeshStandardMaterial({ color: 0xff4b6e }));
      mesh.userData.label = 'OOS';
      mesh.position.set((Math.random()*2-1)*1.1, 0.25, -30);
    }else if(type==='fall'){
      const s = 0.45 + Math.random()*0.3;
      mesh = new THREE.Mesh(new THREE.BoxGeometry(s,s,s), new THREE.MeshStandardMaterial({ color: 0xe8a36b }));
      mesh.userData.fall = true;
      mesh.userData.vy = 0.02 + Math.random()*0.02;
      mesh.position.set((Math.random()*2-1)*1.1, 3 + Math.random()*1.5, -30);
      mesh.userData.label = '–ù–µ—Ç —Å—Ç–æ–∫–∞';
    }else{
      const w = 0.7 + Math.random()*0.4;
      const h = 0.35 + Math.random()*0.2;
      mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,0.5), new THREE.MeshStandardMaterial({ color: 0xffb84b }));
      mesh.position.set((Math.random()*2-1)*1.1, h/2, -30);
      mesh.userData.label = 'ERP —É–ø–∞–ª';
    }
    mesh.castShadow = true;
    obstacles.push(mesh);
    scene.add(mesh);
  }

  function spawnGoodie(){
    const r = Math.random();
    const type = r<0.5 ? 'discount' : (r<0.8 ? 'prepack':'erid');
    let color = type==='discount' ? 0x2b7bd4 : (type==='prepack' ? 0x00d6ff : 0x7a4bd4);
    const mesh = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.06, 16, 24), new THREE.MeshStandardMaterial({ color }));
    mesh.position.set((Math.random()*2-1)*1.1, 0.9 + Math.random()*0.8, -28);
    mesh.castShadow=true;
    mesh.userData.type = type;
    goodies.push(mesh); scene.add(mesh);
  }

  function spawnCrumbs(){
    const n = 5 + Math.floor(Math.random()*4);
    for(let i=0;i<n;i++){
      const s = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 8), new THREE.MeshStandardMaterial({ color: 0x6d3b2a }));
      s.position.set((Math.random()*2-1)*1.1, 0.7 + Math.sin(i/n*Math.PI)*0.5, -26 - i*0.8);
      s.castShadow=true; crumbs.push(s); scene.add(s);
    }
  }

  // Gameplay state
  const SPEED_UP = 1.04;
  const levels=[
    { name:'–°–∫–ª–∞–¥ –†–¶', seconds:24, speed:0.22*SPEED_UP },
    { name:'–ú–∞–≥–∞–∑–∏–Ω', seconds:28, speed:0.25*SPEED_UP },
    { name:'–ü–µ—Ä–µ–≥–æ–≤–æ—Ä–∫–∞', seconds:32, speed:0.28*SPEED_UP }
  ];
  let levelIdx=0, timeLeft=levels[0].seconds, speed=levels[0].speed, t=0;
  let score=0, best=+localStorage.getItem('mdz_best_crumbs')||0;
  const hud = {
    level: document.getElementById('levelLabel'),
    score: document.getElementById('scoreLabel'),
    best: document.getElementById('bestLabel'),
    status: document.getElementById('statusLabel'),
    toast: document.getElementById('toast'),
    count: document.getElementById('count'),
    start: document.getElementById('startBanner'),
    startBtn: document.getElementById('startBtn'),
    pauseBtn: document.getElementById('pauseBtn'),
    restartBtn: document.getElementById('restartBtn'),
    hint: document.getElementById('hint')
  };

  // Physics & jump feel
  let vy = 0;
  const G = 0.015;
  let groundY = 0.6;
  let jumps=0, onGround=true;
  // coyote time: small grace after leaving ground; jump buffer: small window before landing
  let coyoteTimer=0, jumpBufferTimer=0;
  const COYOTE=0.14, BUFFER=0.14;

  function requestJump(){
    jumpBufferTimer = BUFFER; // remember intent
    tryPerformJump();
  }
  function tryPerformJump(){
    // allowed if onGround or inside coyote, or second jump
    if((onGround || coyoteTimer>0) && jumps===0){
      vy = 0.36; jumps=1; onGround=false; coyoteTimer=0; jumpBufferTimer=0; return;
    }
    if(!onGround && jumps===1){
      vy = 0.34; jumps=2; jumpBufferTimer=0; return;
    }
  }

  function update(dt){
    t += dt;
    timeLeft -= dt;
    if(timeLeft<=0){
      levelIdx++;
      if(levelIdx>=levels.length){ win(); return; }
      levelUp(levelIdx);
    }
    speed = levels[levelIdx].speed + Math.min(0.06, Math.floor(t/12)*0.01);
    ground.position.z += speed*120*dt;
    if(ground.position.z>-20) ground.position.z = -60;

    // spawn
    spawnT-=dt; if(spawnT<=0){ spawnObstacle(); spawnT= 0.7 + Math.random()*0.8; }
    goodieT-=dt; if(goodieT<=0){ spawnGoodie(); goodieT= 1.0 + Math.random()*0.8; }
    crumbT-=dt; if(crumbT<=0){ spawnCrumbs(); crumbT= 0.9 + Math.random()*0.7; }

    // move items toward player (scroll world)
    for(const arr of [obstacles, goodies, crumbs]){
      for(const m of arr){ m.position.z += speed*120*dt; if(m.userData.fall){ m.position.y = Math.max(0.25, m.position.y - (m.userData.vy||0.03)); } }
      for(let i=arr.length-1;i>=0;i--){ if(arr[i].position.z>6) { scene.remove(arr[i]); arr.splice(i,1); } }
    }

    // gravity
    vy -= G * (1 + (jumps===2?0.2:0));
    player.position.y += vy;
    if(player.position.y<=groundY){
      player.position.y = groundY;
      if(!onGround){ onGround=true; jumps=0; }
    }else{
      if(onGround){ onGround=false; coyoteTimer=COYOTE; }
    }
    if(coyoteTimer>0) coyoteTimer -= dt;
    if(jumpBufferTimer>0){ jumpBufferTimer -= dt; if(onGround){ tryPerformJump(); } }

    // collisions
    const px=player.position.x, py=player.position.y, pz=player.position.z;
    for(let i=obstacles.length-1;i>=0;i--){
      const m=obstacles[i];
      if(Math.abs(m.position.z-pz)<0.5 && Math.abs(m.position.x-px)<0.6 && Math.abs(m.position.y-py)<0.5){
        gameOver(); return;
      }
    }
    for(let i=goodies.length-1;i>=0;i--){
      const m=goodies[i];
      if(m.position.distanceTo(player.position)<0.7){
        const type=m.userData.type;
        if(type==='discount'){ speedBoost=1.6; boostTimer=2.8; toast('–î–æ–ø—Å–∫–∏–¥–∫–∞ +3% üöÄ'); }
        else if(type==='prepack'){ shieldTimer=3.6; toast('–ü—Ä–µ–ø–∞–∫ ‚Äî —â–∏—Ç'); }
        else { toast('–°–æ–≥–ª–∞—Å–æ–≤–∞–Ω–æ –±–µ–∑ ERID ‚ú®'); }
        scene.remove(m); goodies.splice(i,1);
      }
    }
    for(let i=crumbs.length-1;i>=0;i--){
      const m=crumbs[i];
      if(m.position.distanceTo(player.position)<0.6){
        score++; scene.remove(m); crumbs.splice(i,1);
      }
    }

    // boosters
    if(boostTimer>0){ boostTimer-=dt; speed*=speedBoost; }
    if(shieldTimer>0){ shieldTimer-=dt; }

    // eyes blink
    player.rotation.y = Math.sin(t*0.7)*0.1;

    // UI
    hud.score.textContent = '–û—á–∫–∏ (–∫—Ä–æ—à–∫–∏): ' + score;
    hud.best.textContent = '–†–µ–∫–æ—Ä–¥: ' + Math.max(best, score);
    hud.status.textContent = `–û—Å—Ç–∞–ª–æ—Å—å: ${Math.max(0, Math.ceil(timeLeft))}—Å`;
  }

  function levelUp(i){
    timeLeft = levels[i].seconds;
    toast('–£—Ä–æ–≤–µ–Ω—å: '+levels[i].name+' ‚Ä¢ –î–≤–æ–π–Ω–æ–π –ø—Ä—ã–∂–æ–∫');
    hud.level.textContent = '–£—Ä–æ–≤–µ–Ω—å: '+levels[i].name;
  }

  function toast(msg){ hud.toast.textContent=msg; hud.toast.classList.add('show'); clearTimeout(toast._t); toast._t=setTimeout(()=>hud.toast.classList.remove('show'), 2000); }

  // Spawn timers
  let spawnT=0.3, goodieT=0.7, crumbT=0.2;

  // Boosters
  let boostTimer=0, shieldTimer=0, speedBoost=1.0;

  // Loop
  let last=performance.now(), running=false;
  function loop(){
    const now=performance.now(); const dt=Math.min(0.05, (now-last)/1000); last=now;
    if(running) update(dt);
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  loop();

  // Start / Pause / Restart
  function start(){
    hud.start.classList.add('hidden'); document.getElementById('hint').style.display = isTouch ? 'block':'none';
    levelUp(0); score=0; running=false; timeLeft=levels[0].seconds; t=0;
    player.position.set(0, groundY, 0); vy=0; jumps=0; onGround=true; coyoteTimer=0;
    // countdown
    let n=3; hud.count.textContent=n; hud.count.classList.remove('hidden');
    const tick=()=>{ n--; if(n>0){ hud.count.textContent=n; setTimeout(tick, 600);} else { hud.count.classList.add('hidden'); running=true; } };
    setTimeout(tick, 600);
  }

  function gameOver(){
    running=false;
    best = Math.max(best, score); localStorage.setItem('mdz_best_crumbs', best);
    toast('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞');
    setTimeout(start, 1200);
  }
  function win(){
    running=false;
    best = Math.max(best, score); localStorage.setItem('mdz_best_crumbs', best);
    toast('–ì–æ–¥ –∑–∞–∫—Ä—ã—Ç –Ω–∞ 120% KPI üéâ');
    setTimeout(start, 1800);
  }

  // Input
  function onJump(){ requestJump(); }
  window.addEventListener('keydown', e=>{ if(e.code==='Space' || e.code==='ArrowUp') { e.preventDefault(); onJump(); } if(e.code==='KeyP'){ running=!running; }});
  renderer.domElement.addEventListener('pointerdown', onJump, {passive:true});
  if(isTouch){ renderer.domElement.addEventListener('touchstart', onJump, {passive:true}); }

  hud.startBtn.addEventListener('click', start);
  hud.pauseBtn.addEventListener('click', ()=>{ running = !running; });
  hud.restartBtn.addEventListener('click', start);

  // Resize
  window.addEventListener('resize', ()=>{
    const w = window.innerWidth, h=window.innerHeight;
    renderer.setSize(w,h); camera.aspect=w/h; camera.updateProjectionMatrix();
  });

  // Init labels
  hud.level.textContent = '–£—Ä–æ–≤–µ–Ω—å: ‚Äî';
  hud.score.textContent = '–û—á–∫–∏ (–∫—Ä–æ—à–∫–∏): 0';
  hud.best.textContent = '–†–µ–∫–æ—Ä–¥: ' + best;
  hud.status.textContent = '';
})();
</script>
</body>
</html>
