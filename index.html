<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Mondelez Runner ‚Äî 2.5D</title>
<style>
  :root{
    --bg0:#0a0b10; --bg1:#131627; --bg2:#1b2040;
    --milka:#7d60c5; --oreo:#0b5fff; --alpen:#6f2c3f;
    --mint:#00e5a8; --gold:#ffcc33; --rose:#ff5ea8;
    --ui:#eaf6ff; --danger:#ff3b30; --ok:#32d74b;
  }
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg1),var(--bg2) 60%,#000 100%);color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;image-rendering:crisp-edges}
  /* UI overlay */
  #hud{position:fixed;left:0;right:0;top:0;display:flex;justify-content:space-between;gap:8px;padding:10px 14px;pointer-events:none;font-weight:700}
  .pill{backdrop-filter:blur(8px);background:rgba(0,0,0,.3);border:1px solid rgba(255,255,255,.12);padding:8px 12px;border-radius:16px;box-shadow:0 6px 20px rgba(0,0,0,.25)}
  #toast{position:fixed;left:50%;transform:translateX(-50%);top:64px;opacity:0;transition:.3s;white-space:nowrap}
  #toast.show{opacity:1}
  /* Start screen */
  #start{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 600px at 50% 40%,rgba(125,96,197,.25),transparent 70%),linear-gradient(180deg,var(--bg1),#000);}
  .card{width:min(680px,94vw);padding:24px;border-radius:20px;background:rgba(20,22,35,.75);border:1px solid rgba(255,255,255,.12);box-shadow:0 20px 60px rgba(0,0,0,.45)}
  .title{font-size:clamp(28px,5vw,42px);font-weight:900;letter-spacing:.5px;margin:0 0 6px;background:linear-gradient(90deg,var(--oreo),#68a0ff,var(--milka));-webkit-background-clip:text;background-clip:text;color:transparent}
  .subtitle{opacity:.8;margin:0 0 18px}
  .dev{font-family:ui-monospace,Menlo,Consolas,monospace;font-weight:800;letter-spacing:.4px;color:#22ffb9;text-shadow:0 0 10px #22ffb980}
  .hackrow{display:flex;align-items:center;gap:12px;margin:10px 0 18px}
  .avatar{width:52px;height:52px;border-radius:14px;display:grid;place-items:center;background:conic-gradient(from 40deg at 50% 50%,#07f,#5cf,#9df);border:1px solid rgba(255,255,255,.18);box-shadow:0 10px 26px rgba(0,0,0,.35)}
  .avatar span{font-size:22px;font-weight:900;text-shadow:0 1px 18px rgba(255,255,255,.3)}
  .btn{display:inline-flex;align-items:center;gap:10px;padding:14px 18px;border-radius:14px;border:1px solid rgba(255,255,255,.16);background:linear-gradient(180deg,#1d244a,#0f1430);color:#fff;font-weight:800;letter-spacing:.3px;cursor:pointer;box-shadow:0 10px 30px #0008}
  .btn:hover{filter:brightness(1.08)}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;font-weight:700;border-radius:10px;padding:6px 10px;border:1px solid rgba(255,255,255,.16);background:#111a}
  /* Pause hint */
  #hint{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);opacity:.75}
  /* Debug bubble */
  #dbg{position:fixed;top:8px;left:50%;transform:translateX(-50%);font:12px ui-monospace;background:#072;padding:6px 10px;border-radius:10px;display:none}
</style>
</head>
<body>
<div id="wrap"><canvas id="game" width="1280" height="720"></canvas></div>
<div id="hud">
  <div class="pill" id="score">–ö—Ä–æ—à–∫–∏: 0</div>
  <div class="pill" id="lvl">–£—Ä–æ–≤–µ–Ω—å: ‚Äî</div>
  <div class="pill" id="shield" style="display:none">–©–∏—Ç: 0—Å</div>
</div>
<div id="toast" class="pill">–¢–æ—Å—Ç</div>
<div id="hint" class="pill">–ú–æ–±–∞–π–ª: —Ç–∞–ø ‚Äî –ø—Ä—ã–∂–æ–∫ (–¥–≤–æ–π–Ω–æ–π ‚Äî –≤ –≤–æ–∑–¥—É—Ö–µ) ‚Ä¢ –ü–ö: <span class="kbd">Space/‚Üë</span></div>
<div id="dbg"></div>

<!-- START SCREEN -->
<section id="start">
  <div class="card">
    <h1 class="title">Mondelez Runner ‚Äî 2.5D</h1>
    <p class="subtitle">–°–æ–±–∏—Ä–∞–π —à–æ–∫–æ–ª–∞–¥–Ω—ã–µ –∫—Ä–æ—à–∫–∏, –∏–∑–±–µ–≥–∞–π ¬´ERP —É–ø–∞–ª¬ª –∏ ¬´OOS¬ª. –ü—Ä–æ–π–¥–∏ 3 —Å—Ü–µ–Ω—ã: <b>–†–¶ ‚Üí –ú–∞–≥–∞–∑–∏–Ω ‚Üí –ü–µ—Ä–µ–≥–æ–≤–æ—Ä–∫–∞</b>.</p>
    <div class="hackrow">
      <div class="avatar"><span>CEO</span></div>
      <div>
        <div class="dev">Œõl—î–∫—ÅŒ±ndr R√∏d—ñonœÉv ‚Ä¢ Œõl—îx—îy Bl—ñnœÉv</div>
        <small style="opacity:.7">¬´–•–∞–∫–µ—Ä—Å–∫–∏–µ CEO¬ª FMCG edition</small>
      </div>
    </div>
    <button id="btnStart" class="btn">START ‚ñ∂</button>
    <div style="margin-top:14px;opacity:.8">
      –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: <span class="kbd">Space</span>/<span class="kbd">‚Üë</span> –∏–ª–∏ —Ç–∞–ø –ø–æ —ç–∫—Ä–∞–Ω—É. –î–≤–æ–π–Ω–æ–π –ø—Ä—ã–∂–æ–∫ ‚Äî –≤—Ç–æ—Ä–æ–π —Ç–∞–ø –≤ –≤–æ–∑–¥—É—Ö–µ.
    </div>
  </div>
</section>

<script>
(() => {
  'use strict';

  // ===== Utilities =====
  const rnd = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v, lo, hi) => v<lo?lo : v>hi?hi : v;
  const now = () => performance.now();

  // ===== Canvas & HiDPI =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hudScore = document.getElementById('score');
  const hudLvl = document.getElementById('lvl');
  const hudShield = document.getElementById('shield');
  const toast = document.getElementById('toast');
  const dbg = document.getElementById('dbg');
  const startScreen = document.getElementById('start');
  const btnStart = document.getElementById('btnStart');

  let W = 1280, H = 720, DPR = 1;
  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const w = window.innerWidth, h = window.innerHeight;
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    W = canvas.width; H = canvas.height;
    // Reference height for world scale
    world.scale = H / 720;
  }
  window.addEventListener('resize', resize, {passive:true});

  // ===== Game State =====
  const GS = {MENU:0, COUNT:1, PLAY:2, PAUSE:3, OVER:4, WIN:5};
  let state = GS.MENU;
  let t0 = now(), dt = 0, lt = t0;

  // ===== World / Level =====
  const world = {
    scale: 1,
    speed: 7.5,        // base speed
    speedMul: 1.0,     // dynamic multiplier
    gravity: 0.78,     // tuned with scale
    level: 1,
    crumbs: 0,
    stageCrumbs: 0,
    targetPerStage: 18, // crumbs to advance per stage
    maxLevel: 3,
    bannerTime: 0,
    shieldTime: 0,
    boostTime: 0,
    confettiTime: 0,
    msgCooldown: 0,
  };

  // Difficulty tweak (+4% tempo already baked-in)
  const DIFF = {
    coyote: 110,   // ms
    jumpBuffer: 130,
    jumpV: 17.2,
    jump2V: 15.2,
    maxFall: 28,
    spawnMin: 800,
    spawnMax: 1500,
    crumbEvery: 420, // ms between crumbs spawn attempts
  };

  // ===== Player (Oreo cookie) =====
  const player = {
    x: 0, y: 0, z: 0,
    w: 70, h: 70,
    vx: 0, vy: 0,
    onGround: false,
    jumps: 0,
    lastGroundTime: 0,
    lastJumpPress: 0,
    invul: 0, // shield seconds
    blink: 0, // eye blink timer
  };

  // World lanes (2.5D fake): we just shift Y a little by z (lane depth)
  const lanes = [0, 1, 2]; // center, back, front (visual only)
  let lane = 0;

  // Entities
  const ents = [];
  function spawnObstacle(kind){
    // kind: 'box','erp','cart'
    const s = world.scale;
    const baseH = 70*s;
    const e = {
      kind,
      x: canvas.width + 80*s,
      y: groundY(),
      z: 0,
      w: kind==='erp' ? 90*s : 68*s,
      h: kind==='erp' ? 120*s : baseH,
      vx: - (world.speed * world.speedMul) * 1.0 * DPR,
      hit:true
    };
    if(kind==='cart'){ e.h = 60*s; e.w = 120*s; e.y -= 10*s; }
    if(kind==='erp'){ e.w = 80*s; e.h = 140*s; }
    ents.push(e);
  }
  function spawnCrumb(){
    const s = world.scale;
    const e = {
      kind:'crumb',
      x: canvas.width + 40*s,
      y: groundY() - rnd(80*s, 220*s),
      z: 0,
      r: 12*s,
      vx: - (world.speed * world.speedMul) * 1.0 * DPR,
      hit:false
    };
    ents.push(e);
  }
  function spawnPower(){
    const s = world.scale;
    const types = ['shield','boost','eridok'];
    const kind = types[Math.floor(Math.random()*types.length)];
    const e = {
      kind,
      x: canvas.width + 60*s,
      y: groundY() - rnd(60*s, 200*s),
      z: 0,
      r: 16*s,
      vx: - (world.speed * world.speedMul) * 1.0 * DPR,
      hit:false
    };
    ents.push(e);
  }

  // Spawners
  let nextSpawn = 0;
  let nextCrumbTry = 0;
  let nextPowerTry = 2000;

  function groundY(){ return H*0.78; }

  function reset(){
    world.level = 1;
    world.speedMul = 1.0;
    world.crumbs = 0;
    world.stageCrumbs = 0;
    world.bannerTime = 0;
    world.shieldTime = 0;
    world.boostTime = 0;
    world.confettiTime = 0;
    world.msgCooldown = 0;
    player.x = W*0.22;
    player.y = groundY();
    player.vy = 0;
    player.onGround = true;
    player.jumps = 0;
    player.invul = 0;
    ents.length = 0;
    nextSpawn = 600;
    nextCrumbTry = 0;
    nextPowerTry = 2200;
    updateHUD();
  }

  // ===== Input =====
  let pressed = false;
  let wantJump = false;
  function press(){
    pressed = true; wantJump = true; player.lastJumpPress = now();
  }
  function release(){ pressed = false; }
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); press(); }
    if(e.code==='KeyP'){ togglePause(); }
  }, {passive:false});
  window.addEventListener('keyup',(e)=>{
    if(e.code==='Space' || e.code==='ArrowUp'){ release(); }
  },{passive:true});
  // Pointer
  canvas.addEventListener('pointerdown', (e)=>{ press(); }, {passive:true});
  canvas.addEventListener('pointerup', (e)=>{ release(); }, {passive:true});
  // Global tap-to-start fallback (Safari/Telegram quirks)
  document.addEventListener('click', (e)=>{
    if(state === GS.MENU){ startGame(); }
  }, {once:true, passive:true});

  // ===== Jump mechanics: coyote time & jump buffer =====
  function tryJump(){
    const t = now();
    const canCoyote = (t - player.lastGroundTime) <= DIFF.coyote;
    const buffered = (t - player.lastJumpPress) <= DIFF.jumpBuffer;
    if(!buffered) return;

    if(player.onGround || canCoyote){
      // first jump
      player.vy = -DIFF.jumpV * world.scale * DPR;
      player.onGround = false;
      player.jumps = 1;
      wantJump = false;
      return;
    }
    if(!player.onGround && player.jumps === 1){
      // second jump only in air
      player.vy = -DIFF.jump2V * world.scale * DPR;
      player.jumps = 2;
      wantJump = false;
      popToast('–î–≤–æ–π–Ω–æ–π –ø—Ä—ã–∂–æ–∫!');
      return;
    }
  }

  // ===== UI =====
  function popToast(s, color){
    if(world.msgCooldown>0) return;
    toast.textContent = s;
    toast.style.borderColor = color || 'rgba(255,255,255,.16)';
    toast.classList.add('show');
    world.msgCooldown = 1200;
    setTimeout(()=>toast.classList.remove('show'), 950);
  }
  function updateHUD(){
    hudScore.textContent = `–ö—Ä–æ—à–∫–∏: ${world.crumbs}`;
    hudLvl.textContent = `–£—Ä–æ–≤–µ–Ω—å: ${['‚Äî','–†–¶','–ú–∞–≥–∞–∑–∏–Ω','–ü–µ—Ä–µ–≥–æ–≤–æ—Ä–∫–∞'][world.level]}`;
    if(world.shieldTime>0){
      hudShield.style.display='inline-flex';
      hudShield.textContent = `–©–∏—Ç: ${Math.ceil(world.shieldTime/1000)}—Å`;
    } else {
      hudShield.style.display='none';
    }
  }

  // ===== Rendering helpers (2.5D look) =====
  function drawGround(){
    const s = world.scale;
    // perspective floor stripes
    const gy = groundY();
    const stripes = 14;
    for(let i=0;i<stripes;i++){
      const y = gy + i*10*s*DPR;
      const alpha = 0.035 * (1 - i/stripes);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fillRect(0, y, W, 6*DPR);
    }
    // horizon glow
    const grad = ctx.createLinearGradient(0, 0, 0, gy);
    grad.addColorStop(0, 'rgba(125,96,197,.12)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, gy);
  }

  function eye(x,y,r,open=1){
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    // pupil
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.ellipse(x-1.5*DPR,y, r*0.55, r*0.8*open, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(x-1*DPR,y, r*0.35*open, 0, Math.PI*2); ctx.fill();
  }

  function drawOreo(p){
    const s = world.scale;
    const r = (p.w*0.62);
    // body
    const grad = ctx.createRadialGradient(p.x, p.y, r*0.2, p.x, p.y, r);
    grad.addColorStop(0, '#1b1b25');
    grad.addColorStop(1, '#0a0a12');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    // cream ring
    ctx.strokeStyle = '#fafafa';
    ctx.lineWidth = 6*DPR;
    ctx.beginPath(); ctx.arc(p.x, p.y, r*0.78, 0, Math.PI*2); ctx.stroke();
    // eyes
    p.blink -= dt;
    const open = (p.blink>0 && p.blink<90) ? 0.15 : 1;
    eye(p.x - r*0.28, p.y - r*0.08, 10*DPR, open);
    eye(p.x + r*0.28, p.y - r*0.08, 10*DPR, open);
    if(p.blink<=0) p.blink = rnd(800, 2200);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,.4)';
    ctx.beginPath();
    ctx.ellipse(p.x, groundY()+6*DPR, r*0.95, r*0.30, 0, 0, Math.PI*2);
    ctx.fill();
  }

  function drawObstacle(e){
    const s = world.scale;
    if(e.kind==='erp'){
      // tall red wall
      ctx.fillStyle = '#d72638';
      ctx.fillRect(e.x-e.w/2, e.y-e.h, e.w, e.h);
      ctx.fillStyle = '#fff';
      ctx.font = `${14*DPR}px ui-monospace`;
      ctx.fillText('ERP —É–ø–∞–ª', e.x-e.w/2+6*DPR, e.y-e.h+20*DPR);
    } else if(e.kind==='cart'){
      ctx.fillStyle = '#2b9df4';
      ctx.fillRect(e.x-e.w/2, e.y-e.h, e.w, e.h);
      ctx.fillStyle = '#fff';
      ctx.fillRect(e.x-e.w/2+6*DPR, e.y-10*DPR, e.w-12*DPR, 4*DPR);
    } else {
      ctx.fillStyle = '#a87d5a';
      ctx.fillRect(e.x-e.w/2, e.y-e.h, e.w, e.h);
      ctx.strokeStyle = '#6d4c35'; ctx.lineWidth = 3*DPR;
      ctx.strokeRect(e.x-e.w/2, e.y-e.h, e.w, e.h);
    }
  }

  function drawCrumb(e){
    ctx.fillStyle = '#c98b3c';
    ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#5f3a14';
    ctx.beginPath(); ctx.arc(e.x - e.r*0.3, e.y - e.r*0.2, e.r*0.25, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(e.x + e.r*0.2, e.y + e.r*0.15, e.r*0.18, 0, Math.PI*2); ctx.fill();
  }

  function drawPower(e){
    if(e.kind==='shield'){
      ctx.strokeStyle = '#22ffb9'; ctx.lineWidth = 3*DPR;
      ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.stroke();
    } else if(e.kind==='boost'){
      ctx.strokeStyle = '#ffd84d'; ctx.lineWidth = 3*DPR;
      ctx.beginPath(); ctx.moveTo(e.x-e.r, e.y); ctx.lineTo(e.x+e.r, e.y); ctx.stroke();
    } else {
      // erid ok
      ctx.strokeStyle = '#9cf'; ctx.lineWidth = 3*DPR;
      ctx.strokeRect(e.x-e.r, e.y-e.r, e.r*2, e.r*2);
    }
  }

  function backgroundLayers(){
    const s = world.scale;
    const gy = groundY();
    // sky gradient per level
    const g = ctx.createLinearGradient(0,0,0,H);
    if(world.level===1){ g.addColorStop(0,'#0b0e23'); g.addColorStop(1,'#182048'); }
    if(world.level===2){ g.addColorStop(0,'#10152a'); g.addColorStop(1,'#1d254d'); }
    if(world.level===3){ g.addColorStop(0,'#151028'); g.addColorStop(1,'#2b1b38'); }
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    // parallax boxes
    const t = performance.now()*0.00006;
    const speeds = [0.15,0.35,0.7];
    const colors = world.level===1 ? ['#233','#2d3a5f','#446'] :
                   world.level===2 ? ['#223','#37406a','#4a5aa0'] :
                                     ['#232','#523656','#744a88'];
    for(let layer=0; layer<3; layer++){
      const sp = speeds[layer] * world.speed * world.speedMul * 18;
      for(let i=0;i<8;i++){
        const w = 120*s + (i%3)*30*s;
        const h = 80*s + (i%4)*24*s;
        const x = (W - ((t*sp + i*280*s) % (W+300*s))) - 100*s;
        const y = gy - 40*s - layer*70*s - (i%3)*22*s;
        ctx.fillStyle = colors[layer];
        ctx.fillRect(x, y, w, h);
        ctx.fillStyle = 'rgba(255,255,255,.06)';
        ctx.fillRect(x+6*s, y+8*s, w-12*s, 6*s);
      }
    }
  }

  // ===== Game loop =====
  function step(){
    const tn = now();
    dt = tn - lt; lt = tn;
    if(dt>60) dt=60; // clamp

    if(state===GS.PLAY){
      update(dt);
      draw();
    }else if(state===GS.COUNT){
      draw(); // keep anim
    }else{
      // still render subtle bg
      draw();
    }
    requestAnimationFrame(step);
  }

  function update(ms){
    const s = world.scale;
    const gy = groundY();

    // cooldowns
    if(world.msgCooldown>0) world.msgCooldown -= ms;
    if(world.bannerTime>0) world.bannerTime -= ms;
    if(world.shieldTime>0){ world.shieldTime -= ms; if(world.shieldTime<=0) player.invul=0; }
    if(world.boostTime>0){ world.boostTime -= ms; if(world.boostTime<=0) world.speedMul = 1.0; }
    if(world.confettiTime>0){ world.confettiTime -= ms; }

    // input
    if(wantJump){ tryJump(); }

    // physics
    player.vy += world.gravity * DPR * s * (ms/16.6);
    player.vy = clamp(player.vy, -999, DIFF.maxFall * DPR * s);
    player.y += player.vy * (ms/16.6);

    if(player.y >= gy){
      player.y = gy;
      player.onGround = true;
      player.jumps = 0;
      player.lastGroundTime = now();
    }else{
      player.onGround = false;
    }

    // spawn logic
    nextSpawn -= ms;
    if(nextSpawn<=0){
      const kinds = ['box','erp','cart'];
      const k = kinds[Math.floor(Math.random()*kinds.length)];
      spawnObstacle(k);
      const min = DIFF.spawnMin, max = DIFF.spawnMax;
      nextSpawn = rnd(min, max) / world.speedMul;
    }

    nextCrumbTry -= ms;
    if(nextCrumbTry<=0){
      spawnCrumb();
      nextCrumbTry = DIFF.crumbEvery / world.speedMul;
    }

    nextPowerTry -= ms;
    if(nextPowerTry<=0){
      if(Math.random()<0.35) spawnPower();
      nextPowerTry = rnd(2500, 4800);
    }

    // move ents, collisions
    const v = -(world.speed * world.speedMul) * DPR;
    for(let i=ents.length-1;i>=0;i--){
      const e = ents[i];
      e.x += e.vx ?? v;
      // remove offscreen
      if(e.x < -200*DPR){ ents.splice(i,1); continue; }

      // collisions (AABB / circle)
      if(e.kind==='crumb' || e.kind==='shield' || e.kind==='boost' || e.kind==='eridok'){
        const dx = e.x - player.x, dy = e.y - player.y;
        const rr = (e.r || 12*DPR) + (player.w*0.45);
        if(dx*dx + dy*dy <= rr*rr){
          if(e.kind==='crumb'){
            world.crumbs++; world.stageCrumbs++; popToast('+1 –∫—Ä–æ—à–∫–∞', '#2cf');
            ents.splice(i,1);
            updateHUD();
            if(world.stageCrumbs>=world.targetPerStage){
              advanceLevel();
            }
          } else if(e.kind==='shield'){
            player.invul = 1; world.shieldTime = 5500; updateHUD(); popToast('–ü—Ä–µ–ø–∞–∫: —â–∏—Ç 5—Å', '#22ffb9'); ents.splice(i,1);
          } else if(e.kind==='boost'){
            world.speedMul = 1.2; world.boostTime = 3200; popToast('–î–æ–ø—Å–∫–∏–¥–∫–∞: –±—É—Å—Ç', '#ffd84d'); ents.splice(i,1);
          } else if(e.kind==='eridok'){
            world.confettiTime = 1200; popToast('–ë–µ–∑ ERID: —É—Ä–∞!', '#9cf'); ents.splice(i,1);
          }
        }
      } else {
        // obstacle AABB vs player
        const pw = player.w*0.9, ph = player.h*0.9;
        const px = player.x - pw*0.5, py = player.y - ph*0.5;
        const ex = e.x - e.w*0.5, ey = e.y - e.h;
        if(px < ex + e.w && px + pw > ex && py < ey + e.h && py + ph > ey){
          if(player.invul){ // consume shield
            player.invul = 0; world.shieldTime = 0; popToast('–©–∏—Ç —Å–ø–∞—Å!', '#22ffb9');
            ents.splice(i,1);
          } else {
            gameOver();
            return;
          }
        }
      }
    }
  }

  function draw(){
    // bg & parallax
    backgroundLayers();
    drawGround();

    // entities
    ents.forEach(e=>{
      if(e.kind==='crumb') drawCrumb(e);
      else if(e.kind==='shield'||e.kind==='boost'||e.kind==='eridok') drawPower(e);
      else drawObstacle(e);
    });

    // player
    drawOreo(player);

    // level banner
    if(world.bannerTime>0){
      const a = Math.min(1, world.bannerTime/800);
      drawBanner(a);
    }

    // confetti
    if(world.confettiTime>0){
      const n = 36;
      for(let i=0;i<n;i++){
        const ang = (i/n)*Math.PI*2;
        const r = (1 - world.confettiTime/1200) * 260 * world.scale * DPR;
        const x = player.x + Math.cos(ang)*r;
        const y = player.y - 60*world.scale*DPR + Math.sin(ang)*r*0.6;
        ctx.fillStyle = ['#f66','#6f6','#66f','#ff6','#6ff','#f6f'][i%6];
        ctx.fillRect(x, y, 8*DPR, 8*DPR);
      }
    }

    // MENU overlay subtle
    if(state===GS.MENU){
      // Start screen handled by DOM
    }
  }

  function drawBanner(alpha){
    const txt = ['','–£—Ä–æ–≤–µ–Ω—å 1: –°–∫–ª–∞–¥ –†–¶','–£—Ä–æ–≤–µ–Ω—å 2: –ú–∞–≥–∞–∑–∏–Ω','–£—Ä–æ–≤–µ–Ω—å 3: –ü–µ—Ä–µ–≥–æ–≤–æ—Ä–∫–∞'][world.level];
    ctx.save();
    ctx.globalAlpha = alpha;
    const w = W*0.78, h = 80*DPR;
    ctx.fillStyle = 'rgba(0,0,0,.45)';
    ctx.fillRect((W-w)/2, 42*DPR, w, h);
    ctx.strokeStyle = 'rgba(255,255,255,.25)'; ctx.lineWidth = 2*DPR;
    ctx.strokeRect((W-w)/2, 42*DPR, w, h);
    ctx.fillStyle = '#fff';
    ctx.font = `${28*DPR}px ui-monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(txt, W/2, 42*DPR+52*DPR);
    ctx.restore();
  }

  function advanceLevel(){
    if(world.level < world.maxLevel){
      world.level++;
      world.stageCrumbs = 0;
      world.bannerTime = 1600;
      popToast('–°–º–µ–Ω–∞ —Å—Ü–µ–Ω—ã!', '#7d60c5');
      updateHUD();
    } else {
      win();
    }
  }

  function gameOver(){
    state = GS.OVER;
    popToast('–õ–æ–≥–∏—Å—Ç–∏–∫–∞ –æ—Ç–º–µ–Ω–∏–ª–∞ –æ—Ç–≥—Ä—É–∑–∫—É üòÖ', '#ff7373');
    // simple restart after short delay
    setTimeout(()=>{
      reset(); startCountdown();
    }, 1400);
  }

  function win(){
    state = GS.WIN;
    popToast('–ì–æ–¥ –∑–∞–∫—Ä—ã—Ç –Ω–∞ 120% KPI üéÜ', '#7dff73');
    setTimeout(()=>{
      reset(); startCountdown();
    }, 1800);
  }

  function startCountdown(){
    state = GS.COUNT;
    let c = 3;
    const id = setInterval(()=>{
      popToast(String(c), '#9cf');
      c--;
      if(c===0){ clearInterval(id); state=GS.PLAY; }
    }, 500);
  }

  function togglePause(){
    if(state===GS.PLAY){ state=GS.PAUSE; popToast('–ü–∞—É–∑–∞'); }
    else if(state===GS.PAUSE){ state=GS.PLAY; popToast('–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º'); }
  }

  function startGame(){
    startScreen.style.display='none';
    reset();
    startCountdown();
  }
  btnStart.addEventListener('click', startGame);

  // Init
  resize();
  step();
})();
</script>
</body>
</html>
