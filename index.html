<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Mondelez Runner ‚Äî 3D</title>
<meta name="description" content="3D —Ä–∞–Ω–Ω–µ—Ä –≤ —Å—Ç–∏–ª–µ FMCG. –û—Ä–µ–æ —Å–æ–±–∏—Ä–∞–µ—Ç —à–æ–∫–æ–ª–∞–¥–Ω—ã–µ –∫—Ä–æ—à–∫–∏, –∏–∑–±–µ–≥–∞–µ—Ç OOS –∏ ERP-—Å—Ç–µ–Ω.">
<style>
  :root{
    --violet:#6d4aff; /* –∞–∫—Ü–µ–Ω—Ç */
    --milka:#7851a9;
    --oreo:#0b57cf;
    --bg:#0b1020;
    --glass:rgba(255,255,255,.06);
    --glass-2:rgba(255,255,255,.1);
    --lime:#2dd4bf;
    --error:#ff5370;
    --gold:#ffd166;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b1020,#151a2e);color:#eef;overflow:hidden;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
  #ui{position:fixed;inset:0;pointer-events:none}
  #hud{position:absolute;left:16px;top:16px;display:flex;gap:12px;align-items:center;padding:10px 12px;background:var(--glass);backdrop-filter:blur(8px);border:1px solid var(--glass-2);border-radius:14px;font-weight:700}
  #hud .badge{padding:4px 8px;border-radius:10px;background:var(--glass-2);font-weight:700}
  #hud .score{font-size:18px}
  #hud .level{font-size:14px;opacity:.85}
  #toast{position:absolute;top:72px;left:16px;max-width:min(560px,92vw);pointer-events:none}
  .toast{
    margin:10px 0;padding:10px 12px;border-radius:12px;
    background:var(--glass);backdrop-filter:blur(8px);
    border:1px solid var(--glass-2);font-weight:600;opacity:0;transform:translateY(-8px);
    animation:toast-in .3s ease forwards;
  }
  @keyframes toast-in{to{opacity:1;transform:translateY(0)}}
  #start, #gameover, #win{
    position:absolute;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 600px at 50% 0, rgba(255,255,255,.07), transparent 60%);
    pointer-events:auto;
  }
  .panel{
    width:min(640px,92vw);padding:28px;border-radius:20px;background:rgba(10,12,24,.75);
    border:1px solid rgba(255,255,255,.08);box-shadow:0 10px 40px rgba(0,0,0,.45);
  }
  h1{margin:0 0 10px;font-size:clamp(28px,4.2vw,40px);letter-spacing:.5px}
  .subtitle{opacity:.9;margin-bottom:16px}
  .hackers{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}
  .tag{background:var(--glass-2);border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:999px;font-weight:700}
  .avatars{display:flex;gap:12px;margin:14px 0 18px}
  .avatar{
    width:64px;height:64px;border-radius:16px;background:conic-gradient(from 120deg,var(--oreo),var(--milka),var(--violet),var(--oreo));
    display:grid;place-items:center;font-weight:900;color:white;border:2px solid rgba(255,255,255,.2);
    box-shadow:0 8px 24px rgba(0,0,0,.35);
  }
  button.primary{
    pointer-events:auto;cursor:pointer;appearance:none;
    background:linear-gradient(90deg,var(--violet),var(--oreo));
    border:none;color:white;font-weight:800;letter-spacing:.6px;
    padding:14px 20px;border-radius:14px;font-size:16px;
    box-shadow:0 12px 30px rgba(13,110,253,.25);
    transition:transform .08s ease,filter .08s ease;
  }
  button.primary:active{transform:translateY(1px);filter:saturate(1.2)}
  .hint{opacity:.8;margin-top:10px;font-size:14px}
  #canvas{position:fixed;inset:0;display:block}
  .blink{animation:blink 1.2s steps(2,end) infinite}
  @keyframes blink{50%{opacity:.3}}
  /* Mobile A11y tap helper */
  #tap{position:fixed;inset:0;pointer-events:auto}
  #tap.hidden{display:none}
  .debug{position:absolute;right:10px;top:10px;padding:6px 8px;border-radius:8px;background:var(--glass);border:1px solid var(--glass-2);font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
</style>
</head>
<body>
<canvas id="canvas" aria-label="3D scene"></canvas>
<div id="ui" aria-hidden="true">
  <div id="hud">
    <div class="badge level">–£—Ä–æ–≤–µ–Ω—å: <span id="levelName">–°–∫–ª–∞–¥ –†–¶</span></div>
    <div class="badge score">–ö—Ä–æ—à–∫–∏: <span id="score">0</span></div>
    <div class="badge">–õ—É—á—à–∏–π: <span id="best">0</span></div>
  </div>
  <div id="toast"></div>

  <div id="start">
    <div class="panel">
      <h1>Mondelez Runner <span class="blink">‚ñà</span></h1>
      <div class="subtitle">–û—Ä–µ–æ —Å–æ–±–∏—Ä–∞–µ—Ç –∫—Ä–æ—à–∫–∏, —É–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –æ—Ç OOS –∏ <span style="white-space:nowrap">¬´ERP —É–ø–∞–ª¬ª</span>. –î–≤–æ–π–Ω–æ–π –ø—Ä—ã–∂–æ–∫ –≤–∫–ª—é—á—ë–Ω.</div>
      <div class="hackers">
        <div class="tag">Developed by</div>
        <div class="tag">Œõl—î–∫—ÅŒ±ndr R√∏d—ñonœÉv</div>
        <div class="tag">Œõl—îx—îy Bl—ñnœÉv</div>
      </div>
      <div class="avatars">
        <div class="avatar">CEO</div>
        <div class="avatar">CEO</div>
      </div>
      <button id="btnStart" class="primary">START</button>
      <div class="hint">–ú–æ–±–∞–π–ª: —Ç–∞–ø = –ø—Ä—ã–∂–æ–∫ (2 —Ä–∞–∑–∞ –≤ –≤–æ–∑–¥—É—Ö–µ). –ü–ö: Space/‚Üë ‚Äî –ø—Ä—ã–∂–æ–∫, –¥–≤–æ–π–Ω–æ–π –≤ –≤–æ–∑–¥—É—Ö–µ.</div>
    </div>
  </div>

  <div id="gameover" style="display:none">
    <div class="panel">
      <h1 style="color:var(--error)">ERP —É–ø–∞–ª üòÖ</h1>
      <div class="subtitle">–¢—ã –≤—Ä–µ–∑–∞–ª—Å—è. –ù–æ –Ω–∏—á–µ–≥–æ ‚Äî –µ—Å—Ç—å ¬´–ø—Ä–µ–ø–∞–∫¬ª –Ω–∞ —Ä–µ–≤–∞–Ω—à!</div>
      <button id="btnRetry" class="primary">–ó–∞–Ω–æ–≤–æ</button>
      <div class="hint">–°–æ–≤–µ—Ç: –∫–æ–ø–∏ –∫—Ä–æ—à–∫–∏ –∏ –∏—â–∏ –±—É—Å—Ç—ã.</div>
    </div>
  </div>

  <div id="win" style="display:none">
    <div class="panel">
      <h1 style="color:var(--lime)">–ì–æ–¥ –∑–∞–∫—Ä—ã—Ç –Ω–∞ 120% KPI üéÜ</h1>
      <div class="subtitle">Developed by: Œõl—î–∫—ÅŒ±ndr R√∏d—ñonœÉv &amp; Œõl—îx—îy Bl—ñnœÉv <span class="blink">‚ñà</span></div>
      <button id="btnWinRetry" class="primary">–ï—â—ë —Ä–∞–∑!</button>
    </div>
  </div>

  <div id="tap" class=""></div>
</div>

<!-- Three.js UMD -->
<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

<script>
(() => {
  const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

  // --------- Renderer / Scene / Camera
  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, powerPreference:'high-performance', alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0b1020, 20, 120);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500);
  camera.position.set(0, 2.1, 6);
  camera.lookAt(0, 1.2, 0);

  // --------- Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.7);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(5, 8, 4);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048, 2048);
  dir.shadow.camera.near = 0.5;
  dir.shadow.camera.far = 50;
  scene.add(dir);

  // --------- Ground (moving stripes to fake speed)
  const groundGeo = new THREE.PlaneGeometry(200, 20, 1, 1);
  const groundMat = new THREE.MeshStandardMaterial({color:0x20263f, roughness:1, metalness:0});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = 0;
  ground.receiveShadow = true;
  scene.add(ground);

  // Lane markers
  const laneGroup = new THREE.Group();
  scene.add(laneGroup);
  function makeLaneZ(z, color){
    const g = new THREE.PlaneGeometry(200, .15);
    const m = new THREE.MeshBasicMaterial({color, side:THREE.DoubleSide});
    const line = new THREE.Mesh(g, m);
    line.rotation.x = -Math.PI/2;
    line.position.set(0, 0.01, z);
    laneGroup.add(line);
  }
  makeLaneZ(0, 0x5563a6);
  makeLaneZ(-2, 0x445399);
  makeLaneZ(+2, 0x445399);

  // --------- Player (Oreo cookie with eyes)
  const playerGroup = new THREE.Group();
  scene.add(playerGroup);

  const bodyGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.24, 40);
  const bodyMat = new THREE.MeshStandardMaterial({color:0x0b57cf, roughness:.6, metalness:.1});
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.castShadow = true;
  playerGroup.add(body);

  // cream
  const creamGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.08, 40);
  const creamMat = new THREE.MeshStandardMaterial({color:0xffffff, roughness:.5, metalness:.05});
  const cream = new THREE.Mesh(creamGeo, creamMat);
  cream.position.y = 0.06;
  cream.castShadow = true;
  playerGroup.add(cream);

  // eyes
  const eyeGeo = new THREE.SphereGeometry(0.08, 16, 16);
  const pupilGeo = new THREE.SphereGeometry(0.04, 16, 16);
  const white = new THREE.MeshStandardMaterial({color:0xffffff});
  const black = new THREE.MeshStandardMaterial({color:0x111111});

  function makeEye(x){
    const e = new THREE.Group();
    const eyeball = new THREE.Mesh(eyeGeo, white);
    const pupil = new THREE.Mesh(pupilGeo, black);
    pupil.position.z = 0.06;
    eyeball.add(pupil);
    eyeball.position.set(x, .12, .46);
    e.add(eyeball);
    return e;
  }
  const eyeL = makeEye(-.22);
  const eyeR = makeEye(.22);
  playerGroup.add(eyeL, eyeR);

  playerGroup.position.set(0, 1.1, 0);

  // Player physics
  let vy = 0;
  const GRAV = -22;         // –º—è–≥–∫–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è (–±—ã–ª–∞ -26)
  const JUMP_V = 9.9;       // –ø–µ—Ä–≤—ã–π –ø—Ä—ã–∂–æ–∫
  const JUMP_V2 = 9.2;      // –≤—Ç–æ—Ä–æ–π –ø—Ä—ã–∂–æ–∫
  let onGround = true;
  let jumpsLeft = 2;
  let coyoteTime = 0;       // ms coyote
  let bufferTime = 0;       // ms jump buffer
  const COYOTE_MS = 110;
  const BUFFER_MS = 130;

  const lanes = [ -2, 0, 2 ];
  let laneIndex = 1; // —Ü–µ–Ω—Ç—Ä
  playerGroup.position.z = lanes[laneIndex];

  // --------- Obstacles & Chips
  const obstacles = [];
  const chips = [];
  const effects = []; // visual fx
  const tmpBox = new THREE.Box3();
  const tmpBox2 = new THREE.Box3();

  function makeObstacle(zLane){
    const h = 1 + Math.random()*1.2;
    const w = 0.9 + Math.random()*0.7;
    const d = 0.8;
    const g = new THREE.BoxGeometry(w,h,d);
    const m = new THREE.MeshStandardMaterial({color:0xaa3344, roughness:.8});
    const box = new THREE.Mesh(g,m);
    box.castShadow = true;
    box.position.set(20, h/2, zLane);
    scene.add(box);
    obstacles.push(box);
  }

  function makeERPWall(zLane){
    const g = new THREE.BoxGeometry(1.4, 1.6, 0.8);
    const m = new THREE.MeshStandardMaterial({color:0xd9534f, roughness:.7, metalness:.05});
    const wall = new THREE.Mesh(g,m);
    wall.castShadow = true;
    wall.position.set(20, 0.8, zLane);
    scene.add(wall);
    obstacles.push(wall);
  }

  function makeChip(zLane){
    const g = new THREE.SphereGeometry(0.22, 20, 20);
    const m = new THREE.MeshStandardMaterial({color:0xffc866, emissive:0x442200, emissiveIntensity:.2, roughness:.4, metalness:.2});
    const chip = new THREE.Mesh(g,m);
    chip.castShadow = true;
    chip.position.set(22, 1 + Math.random()*1.8, zLane);
    scene.add(chip);
    chips.push(chip);
  }

  // --------- UI
  const elScore = document.getElementById('score');
  const elBest = document.getElementById('best');
  const elLevel = document.getElementById('levelName');
  const toastRoot = document.getElementById('toast');

  let score = 0;
  let best = +localStorage.getItem('mondelez.best') || 0;
  elBest.textContent = best;

  function toast(text){
    const t = document.createElement('div');
    t.className = 'toast';
    t.textContent = text;
    toastRoot.appendChild(t);
    setTimeout(()=> t.remove(), 2600);
  }

  const fmcgToasts = [
    'OOS –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥—ë–Ω ‚Äî –ø–æ–ª–∫–∏ –ø–æ–ø–æ–ª–Ω–µ–Ω—ã üßÉ',
    '–°–µ—Ç—å —Å–æ–≥–ª–∞—Å–æ–≤–∞–ª–∞ –¥–∏–∑–∞–π–Ω –±–µ–∑ ERID ‚ú®',
    '–î–æ–ø—Å–∫–∏–¥–∫–∞ +3% –ø–æ–ª—É—á–∏–ª–∞ –∞–ø–ø—Ä—É–≤ üìà',
    'ERP –º–æ—Ä–≥–Ω—É–ª, –Ω–æ –≤—ã—Å—Ç–æ—è–ª–∏ üíæ',
    '–ü—Ä–µ–ø–∞–∫ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ –†–¶ üöö',
    '–ö–æ—Ñ–µ –≤ –ø–µ—Ä–µ–≥–æ–≤–æ—Ä–∫–µ –∑–∞—Ä—è–∂–µ–Ω ‚òï',
  ];

  // --------- Game State
  const State = { START:0, RUN:1, OVER:2, WIN:3 };
  let state = State.START;
  const startOverlay = document.getElementById('start');
  const overOverlay  = document.getElementById('gameover');
  const winOverlay   = document.getElementById('win');
  const btnStart = document.getElementById('btnStart');
  const btnRetry = document.getElementById('btnRetry');
  const btnWinRetry = document.getElementById('btnWinRetry');

  function resetRun(){
    // clear obstacles/chips
    for(const o of obstacles){ scene.remove(o); }
    for(const c of chips){ scene.remove(c); }
    obstacles.length = 0; chips.length = 0; effects.length = 0;
    // player
    playerGroup.position.set(0,1.1, lanes[1]);
    laneIndex = 1; vy = 0; onGround = true; jumpsLeft = 2; coyoteTime = 0; bufferTime = 0;
    // scoring
    score = 0; elScore.textContent = score;
    // level
    levelTime = 0; spawnTimer = 0; chipTimer = 0;
    setLevel(0);
    toast('3‚Ä¶ 2‚Ä¶ 1‚Ä¶ –ü–æ–µ—Ö–∞–ª–∏!');
  }

  function showStart(){
    state = State.START;
    startOverlay.style.display = '';
    overOverlay.style.display = 'none';
    winOverlay.style.display = 'none';
  }
  function startGame(){
    resetRun();
    state = State.RUN;
    startOverlay.style.display = 'none';
    overOverlay.style.display = 'none';
    winOverlay.style.display = 'none';
  }
  function gameOver(){
    state = State.OVER;
    overOverlay.style.display = '';
  }
  function win(){
    state = State.WIN;
    winOverlay.style.display = '';
  }

  btnStart.addEventListener('click', startGame, {passive:true});
  btnRetry.addEventListener('click', ()=>{ startGame(); }, {passive:true});
  btnWinRetry.addEventListener('click', ()=>{ startGame(); }, {passive:true});

  // --------- Levels (3 themed segments)
  const levels = [
    { name:'–°–∫–ª–∞–¥ –†–¶',  len: 35, speed: 9.4,  spawn: 1.15, chip: .65, wallChance:.18 },
    { name:'–ú–∞–≥–∞–∑–∏–Ω',   len: 40, speed: 10.2, spawn: 1.00, chip: .60, wallChance:.22 },
    { name:'–ü–µ—Ä–µ–≥–æ–≤–æ—Ä–∫–∞', len: 45, speed: 10.8, spawn: 0.92, chip: .55, wallChance:.26 },
  ];
  let levelIndex = 0;
  let levelTime = 0;
  let speed = levels[0].speed;
  let spawnTimer = 0;
  let chipTimer = 0;

  function setLevel(i){
    levelIndex = i;
    elLevel.textContent = levels[i].name;
    speed = levels[i].speed * 1.04; // +4% —Ç–µ–º–ø–∞, –∫–∞–∫ –ø—Ä–æ—Å–∏–ª
    scene.background = new THREE.Color([0x0b1020, 0x10182e, 0x0f1c2f][i]);
    scene.fog.color = scene.background;
    toast('–£—Ä–æ–≤–µ–Ω—å: ' + levels[i].name);
  }

  // --------- Controls (jump with coyote & buffer, lane swipe)
  let wantJump = false;
  let wantLaneDelta = 0;

  function handleJump(){
    const now = performance.now();
    // buffered input
    bufferTime = now + BUFFER_MS;

    if (onGround || now <= coyoteTime){
      vy = JUMP_V;
      onGround = false;
      jumpsLeft = 1;
    } else if (jumpsLeft > 0){
      vy = JUMP_V2;
      jumpsLeft = 0;
    }
  }

  function onPointerDown(e){
    if(state === State.START){ startGame(); return; }
    if(state !== State.RUN){ return; }
    handleJump();
  }

  function onKeyDown(e){
    if(state === State.START && (e.code==='Space'||e.code==='ArrowUp'||e.code==='Enter')){ startGame(); return; }
    if(state !== State.RUN) return;
    if(e.code==='Space' || e.code==='ArrowUp'){ handleJump(); }
    if(e.code==='ArrowLeft'){ laneIndex = Math.max(0, laneIndex-1); playerGroup.position.z = lanes[laneIndex]; }
    if(e.code==='ArrowRight'){ laneIndex = Math.min(lanes.length-1, laneIndex+1); playerGroup.position.z = lanes[laneIndex]; }
  }

  window.addEventListener('pointerdown', onPointerDown, {passive:true});
  window.addEventListener('keydown', onKeyDown);

  // --------- Resize
  function onResize(){
    const w = innerWidth, h = innerHeight;
    camera.aspect = w/h; camera.updateProjectionMatrix();
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(w, h, false);
  }
  addEventListener('resize', onResize);

  // --------- FX helper
  function spark(pos, color=0xffc866){
    const g = new THREE.SphereGeometry(0.03, 6, 6);
    const m = new THREE.MeshBasicMaterial({color});
    const n = 12;
    for(let i=0;i<n;i++){
      const p = new THREE.Mesh(g,m);
      p.position.copy(pos);
      p.userData.v = new THREE.Vector3(
        (Math.random()-0.5)*2,
        Math.random()*2,
        (Math.random()-0.5)*2
      );
      p.userData.life = 0.4 + Math.random()*0.3;
      effects.push(p); scene.add(p);
    }
  }

  // --------- Main loop
  let last = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dt = Math.min(0.033, (now-last)/1000); last = now;

    if(state === State.RUN){
      levelTime += dt;
      spawnTimer += dt;
      chipTimer  += dt;

      // progress levels
      if(levelTime > levels[levelIndex].len){
        if(levelIndex < levels.length-1){
          setLevel(levelIndex+1);
          levelTime = 0;
        } else {
          // WIN
          localStorage.setItem('mondelez.best', Math.max(best, score));
          elBest.textContent = Math.max(best, score);
          win();
        }
      }

      // spawn obstacles
      const L = levels[levelIndex];
      const spawnEvery = L.spawn;
      if(spawnTimer >= spawnEvery){
        spawnTimer = 0;
        const lane = lanes[(Math.random()*lanes.length)|0];
        if(Math.random() < L.wallChance){
          makeERPWall(lane);
        } else {
          makeObstacle(lane);
        }
        if(Math.random()<0.5) toast(fmcgToasts[(Math.random()*fmcgToasts.length)|0]);
      }

      // spawn chips
      const chipEvery = L.chip;
      if(chipTimer >= chipEvery){
        chipTimer = 0;
        makeChip(lanes[(Math.random()*lanes.length)|0]);
      }

      // move world towards player
      const worldSpeed = speed * dt;
      for(let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        o.position.x -= worldSpeed;
        if(o.position.x < -8){ scene.remove(o); obstacles.splice(i,1); }
      }
      for(let i=chips.length-1;i>=0;i--){
        const c = chips[i];
        c.position.x -= worldSpeed;
        c.rotation.y += dt*3;
        if(c.position.x < -8){ scene.remove(c); chips.splice(i,1); }
      }

      // player physics
      vy += GRAV*dt;
      playerGroup.position.y += vy*dt;
      if(playerGroup.position.y <= 1.1){
        playerGroup.position.y = 1.1;
        if(!onGround){
          onGround = true; jumpsLeft = 2;
        }
        // apply buffered jump if any
        if(bufferTime && performance.now() <= bufferTime){
          bufferTime = 0;
          handleJump();
        }
      } else {
        // set coyote window
        coyoteTime = performance.now() + COYOTE_MS;
      }

      // eye animation looking forward
      const t = now*0.002;
      eyeL.rotation.y = Math.sin(t)*0.15;
      eyeR.rotation.y = Math.cos(t)*0.15;

      // collisions (AABB vs AABB)
      tmpBox.setFromObject(body).expandByScalar(0.05);
      for(const o of obstacles){
        tmpBox2.setFromObject(o);
        if(tmpBox.intersectsBox(tmpBox2)){
          // crash (unless shield in future)
          gameOver();
          if(score>best){ best=score; localStorage.setItem('mondelez.best', best); elBest.textContent = best; }
          break;
        }
      }
      // chip collect
      for(let i=chips.length-1;i>=0;i--){
        const c = chips[i];
        tmpBox2.setFromObject(c);
        if(tmpBox.intersectsBox(tmpBox2)){
          score += 1;
          elScore.textContent = score;
          spark(c.position);
          scene.remove(c); chips.splice(i,1);
        }
      }

      // fx update
      for(let i=effects.length-1;i>=0;i--){
        const p = effects[i];
        p.userData.life -= dt;
        if(p.userData.life<=0){ scene.remove(p); effects.splice(i,1); continue; }
        p.position.addScaledVector(p.userData.v, dt*3);
        p.material.opacity = Math.max(0, p.userData.life*2);
        p.material.transparent = true;
      }
    }

    renderer.render(scene, camera);
  }
  requestAnimationFrame(loop);

  // --------- Safety: ensure taps work
  const tap = document.getElementById('tap');
  tap.addEventListener('pointerdown', (e)=>{
    if(state===State.START){ startGame(); }
    else if(state===State.RUN){ handleJump(); }
    e.preventDefault();
  }, {passive:false});

  // initial toasts
  setTimeout(()=>toast('–°–æ–±–∏—Ä–∞–π —Ç–æ–ª—å–∫–æ –∫—Ä–æ—à–∫–∏ ‚Äî –∑–∞ –Ω–∏—Ö –¥–∞—é—Ç—Å—è –æ—á–∫–∏.'), 500);
  setTimeout(()=>toast('–î–≤–æ–π–Ω–æ–π –ø—Ä—ã–∂–æ–∫: –≤—Ç–æ—Ä–æ–π ‚Äî —Ç–æ–ª—å–∫–æ –≤ –≤–æ–∑–¥—É—Ö–µ.'), 1800);

  // show start
  showStart();
})();
</script>
</body>
</html>
