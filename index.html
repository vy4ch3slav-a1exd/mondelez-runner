<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Linear Runner 2D</title>
<style>
  :root{
    --bg1:#0e1222; --bg2:#161c35; --glass:rgba(255,255,255,.06); --glass2:rgba(255,255,255,.12);
    --violet:#7c4dff; --blue:#0b57cf; --lime:#2dd4bf; --gold:#ffd166; --red:#ff5370; --white:#eef2ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--white);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
  #c{position:fixed;inset:0;display:block;background:transparent}
  #ui{position:fixed;inset:0;pointer-events:none}
  .hud{position:absolute;left:12px;top:12px;display:flex;gap:10px;align-items:center;padding:8px 10px;background:var(--glass);border:1px solid var(--glass2);border-radius:12px;font-weight:700}
  .badge{padding:4px 8px;border-radius:10px;background:var(--glass2)}
  #toasts{position:absolute;left:12px;top:64px;max-width:min(520px,92vw)}
  .toast{margin:8px 0;padding:8px 10px;border-radius:10px;background:var(--glass);border:1px solid var(--glass2);opacity:0;transform:translateY(-6px);animation:in .25s ease forwards}
  @keyframes in{to{opacity:1;transform:translateY(0)}}
  .overlay{position:absolute;inset:0;display:grid;place-items:center;background:radial-gradient(1000px 500px at 50% 0,rgba(255,255,255,.06),transparent 60%)}
  .panel{width:min(620px,92vw);padding:24px;border-radius:18px;background:rgba(10,12,24,.72);border:1px solid var(--glass2)}
  h1{margin:0 0 8px;font-size:clamp(26px,4vw,36px)}
  .sub{opacity:.9;margin-bottom:14px}
  .tags{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
  .tag{padding:6px 10px;border-radius:999px;background:var(--glass2);font-weight:800}
  button.primary{pointer-events:auto;cursor:pointer;appearance:none;border:none;border-radius:14px;background:linear-gradient(90deg,var(--violet),var(--blue));color:white;font-weight:900;letter-spacing:.6px;padding:12px 18px;box-shadow:0 10px 28px rgba(11,87,207,.28)}
  .hint{opacity:.85;margin-top:10px;font-size:14px}
  .blink{animation:bl 1.2s steps(2,end) infinite}
  @keyframes bl{50%{opacity:.2}}
</style>
</head>
<body>
<canvas id="c" aria-label="2D game canvas"></canvas>

<div id="ui">
  <div class="hud">
    <div class="badge">Крошки: <span id="score">0</span></div>
    <div class="badge">Лучший: <span id="best">0</span></div>
    <div class="badge">Зона: <span id="zone">Склад</span></div>
  </div>
  <div id="toasts"></div>

  <div id="start" class="overlay">
    <div class="panel">
      <h1>Linear Runner 2D <span class="blink">█</span></h1>
      <div class="sub">Простой, быстрый и играбельный. Собирай крошки, перепрыгивай препятствия. Двойной прыжок только в воздухе.</div>
      <div class="tags">
        <div class="tag">Λlєксαndr Rødіonσv</div>
        <div class="tag">Λlєxєy Blіnσv</div>
      </div>
      <button id="btnStart" class="primary">START</button>
      <div class="hint">Мобайл: тап — прыжок (2 раза). ПК: Space/↑ — прыжок.</div>
    </div>
  </div>

  <div id="over" class="overlay" style="display:none">
    <div class="panel">
      <h1 style="color:var(--red)">Столкновение</h1>
      <div class="sub">Ты задел препятствие. Попробуй ещё!</div>
      <button id="btnRetry" class="primary">Заново</button>
      <div class="hint">Собирай крошки — только они дают очки.</div>
    </div>
  </div>
</div>

<script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W=0,H=0, DPR=1;

  function resize(){
    DPR = Math.min(devicePixelRatio||1, 2);
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ------- UI
  const elScore = document.getElementById('score');
  const elBest  = document.getElementById('best');
  const elZone  = document.getElementById('zone');
  const toasts  = document.getElementById('toasts');
  const startOv = document.getElementById('start');
  const overOv  = document.getElementById('over');
  const btnStart= document.getElementById('btnStart');
  const btnRetry= document.getElementById('btnRetry');

  let best = +localStorage.getItem('runner2d.best') || 0;
  elBest.textContent = best;

  function toast(msg){
    const d = document.createElement('div');
    d.className = 'toast';
    d.textContent = msg;
    toasts.appendChild(d);
    setTimeout(()=> d.remove(), 2500);
  }

  // ------- Game State
  const State = { START:0, RUN:1, OVER:2 };
  let state = State.START;

  // ------- Level/Zone
  const ZONES = [
    { name:'Склад',     colorTop:'#0e1222', colorBot:'#161c35', speed: 6.2,  spawn: 1.1,  chip: .6 },
    { name:'Магазин',   colorTop:'#12162a', colorBot:'#1b2240', speed: 6.8,  spawn: 1.0,  chip: .55 },
    { name:'Переговорка', colorTop:'#151a2f', colorBot:'#1f2748', speed: 7.3,  spawn: 0.92, chip: .52 }
  ];
  let zoneIndex = 0;
  let zoneTime = 0;
  let speed = ZONES[0].speed * (innerWidth<700?0.9:1); // немного мягче на мобиле
  let spawnT=0, chipT=0;

  function setZone(i){
    zoneIndex = i;
    elZone.textContent = ZONES[i].name;
    speed = ZONES[i].speed * 1.04; // +4% темпа
    document.body.style.background = `linear-gradient(180deg,${ZONES[i].colorTop},${ZONES[i].colorBot})`;
    toast('Зона: ' + ZONES[i].name);
  }

  // ------- Player
  const groundY = Math.floor(H*0.78);
  let px = Math.floor(W*0.22), py = groundY, pv = 0;
  const R  = Math.max(14*DPR, 10);  // радиус печеньки
  let onGround = true;
  let jumpsLeft = 2;
  let coyoteUntil = 0;
  let bufferUntil = 0;
  const GRAV = 1800;       // px/s^2
  const JUMP1= 710;        // px/s
  const JUMP2= 640;        // px/s
  const COYOTE_MS = 110;
  const BUFFER_MS = 130;

  // lanes (only vertical jumps; linear runner)
  // ------- Entities
  const obstacles = []; // {x,y,w,h}
  const chips = [];     // {x,y,r}

  // ------- Input
  function doJump(){
    const now = performance.now();
    bufferUntil = now + BUFFER_MS;
    if(onGround || now <= coyoteUntil){
      pv = -JUMP1;
      onGround = false;
      jumpsLeft = 1;
    } else if (jumpsLeft>0){
      pv = -JUMP2;
      jumpsLeft = 0;
    }
  }

  function onPointerDown(e){
    if(state===State.START){ startGame(); return; }
    if(state!==State.RUN) return;
    doJump();
  }
  function onKeyDown(e){
    if(state===State.START && (e.code==='Space'||e.code==='ArrowUp'||e.code==='Enter')){ startGame(); return; }
    if(state!==State.RUN) return;
    if(e.code==='Space'||e.code==='ArrowUp'){ doJump(); }
  }
  addEventListener('pointerdown', onPointerDown, {passive:true});
  addEventListener('keydown', onKeyDown);

  // ------- Helpers
  function reset(){
    px = Math.floor(W*0.22);
    py = groundY;
    pv = 0;
    onGround = true;
    jumpsLeft = 2;
    coyoteUntil = 0;
    bufferUntil = 0;
    zoneIndex = 0;
    zoneTime = 0;
    spawnT = 0; chipT = 0;
    setZone(0);
    obstacles.length = 0;
    chips.length = 0;
    score = 0;
    elScore.textContent = score;
    // warmup
    for(let i=0;i<6;i++){
      spawnObstacle();
      spawnChip();
    }
  }

  function spawnObstacle(){
    const h = 28*DPR + Math.random()*38*DPR;
    const w = 22*DPR + Math.random()*24*DPR;
    obstacles.push({x: W + Math.random()*W*0.4, y: groundY - h, w, h});
  }
  function spawnChip(){
    const r = 9*DPR + Math.random()*6*DPR;
    const y = groundY - (40*DPR + Math.random()*120*DPR);
    chips.push({x: W + Math.random()*W*0.5, y, r});
  }

  // ------- Start/Over
  function startGame(){
    state = State.RUN;
    startOv.style.display = 'none';
    overOv.style.display = 'none';
    reset();
    toast('3… 2… 1… Поехали!');
  }
  function gameOver(){
    state = State.OVER;
    overOv.style.display = '';
  }

  btnStart.addEventListener('click', startGame, {passive:true});
  btnRetry.addEventListener('click', startGame, {passive:true});

  // ------- Score
  let score = 0;

  // ------- Drawing
  function drawGround(){
    // base line
    ctx.strokeStyle = '#2a335e';
    ctx.lineWidth = 3*DPR;
    ctx.beginPath();
    ctx.moveTo(0, groundY+1*DPR);
    ctx.lineTo(W, groundY+1*DPR);
    ctx.stroke();
    // stripes
    ctx.strokeStyle = '#3b467a';
    ctx.lineWidth = 1*DPR;
    for(let x=0; x<W; x+=24*DPR){
      ctx.beginPath();
      ctx.moveTo(x, groundY+6*DPR);
      ctx.lineTo(x+12*DPR, groundY+6*DPR);
      ctx.stroke();
    }
  }

  function drawPlayer(){
    // body (cookie)
    ctx.save();
    ctx.translate(px, py);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    const shR = Math.max(R*0.9, 8*DPR);
    ctx.beginPath();
    ctx.ellipse(px, groundY+6*DPR, shR, shR*0.4, 0, 0, Math.PI*2);
    ctx.fill();

    // cookie
    const grd = ctx.createLinearGradient(0, -R, 0, R);
    grd.addColorStop(0, '#0b57cf');
    grd.addColorStop(1, '#0a49b0');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, R, 0, Math.PI*2);
    ctx.fill();
    // cream ring
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 5*DPR;
    ctx.beginPath();
    ctx.arc(0, 0, R*0.68, 0, Math.PI*2);
    ctx.stroke();

    // eyes
    const blink = (Math.floor(performance.now()/350)%12===0);
    function eye(ex){
      ctx.save();
      ctx.translate(ex, -R*0.2);
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(0,0, R*0.16, 0, Math.PI*2); ctx.fill();
      if(!blink){
        ctx.fillStyle = '#0e0e0e';
        ctx.beginPath(); ctx.arc(0, R*0.02, R*0.08, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
    eye(-R*0.33);
    eye(+R*0.33);

    ctx.restore();
  }

  function drawOb(o){
    ctx.fillStyle = '#d04b5a';
    ctx.fillRect(o.x, o.y, o.w, o.h);
    // top shine
    ctx.fillStyle = 'rgba(255,255,255,.12)';
    ctx.fillRect(o.x, o.y, o.w, 3*DPR);
  }

  function drawChip(c){
    const grd = ctx.createRadialGradient(c.x-2*DPR, c.y-2*DPR, 2*DPR, c.x, c.y, c.r);
    grd.addColorStop(0, '#ffe099');
    grd.addColorStop(1, '#e7b65a');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
    ctx.fill();
    // sparkle
    ctx.fillStyle = 'rgba(255,255,255,.4)';
    ctx.beginPath();
    ctx.arc(c.x - c.r*0.4, c.y - c.r*0.4, c.r*0.2, 0, Math.PI*2);
    ctx.fill();
  }

  // ------- Loop
  let last = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    // clear
    ctx.clearRect(0,0,W,H);

    if(state===State.RUN){
      zoneTime += dt;
      spawnT += dt;
      chipT  += dt;
      if(zoneTime > 18){ // ~18с на зону
        if(zoneIndex < ZONES.length-1){
          setZone(zoneIndex+1);
          zoneTime = 0;
        } else {
          // остаёмся на последней зоне — бесконечный ран
        }
      }

      // spawn
      if(spawnT >= ZONES[zoneIndex].spawn){
        spawnT = 0;
        spawnObstacle();
        if(Math.random()<0.45) toast(['OOS предотвращён','ERID не нужен','Допскидка +3%','Препак в продакшн'][Math.floor(Math.random()*4)]);
      }
      if(chipT >= ZONES[zoneIndex].chip){
        chipT = 0;
        spawnChip();
      }

      // move world
      const vx = speed * 60 * DPR * dt; // px per frame based on dt
      for(let i=obstacles.length-1;i>=0;i--){
        const o=obstacles[i];
        o.x -= vx;
        if(o.x+o.w < -20*DPR) obstacles.splice(i,1);
      }
      for(let i=chips.length-1;i>=0;i--){
        const c=chips[i];
        c.x -= vx;
        if(c.x+c.r < -20*DPR) chips.splice(i,1);
      }

      // physics
      pv += GRAV*dt;
      py += pv*dt;
      if(py >= groundY){
        py = groundY;
        if(!onGround){
          onGround = true; jumpsLeft = 2;
          // buffered jump?
          if(performance.now() <= bufferUntil){
            bufferUntil = 0;
            doJump();
          }
        }
      }else{
        coyoteUntil = performance.now() + COYOTE_MS;
        onGround = false;
      }

      // collisions
      // player AABB
      const pr = R*0.85; // forgiving hitbox
      const pbox = {x:px-pr, y:py-pr, w:pr*2, h:pr*2};
      // chips
      for(let i=chips.length-1;i>=0;i--){
        const c=chips[i];
        const dx = (c.x - px), dy = (c.y - py);
        if(dx*dx + dy*dy <= (c.r+pr*0.6)*(c.r+pr*0.6)){
          chips.splice(i,1);
          score += 1;
          elScore.textContent = score;
        }
      }
      // obstacles
      for(let i=0;i<obstacles.length;i++){
        const o=obstacles[i];
        if(pbox.x < o.x+o.w && pbox.x+pbox.w > o.x && pbox.y < o.y+o.h && pbox.y+pbox.h > o.y){
          // crash
          if(score>best){ best=score; localStorage.setItem('runner2d.best', best); elBest.textContent = best; }
          gameOver();
          break;
        }
      }
    }

    // draw
    drawGround();
    chips.forEach(drawChip);
    obstacles.forEach(drawOb);
    drawPlayer();
  }
  requestAnimationFrame(loop);

  // Pause on blur (prevents "косой" тайминг)
  addEventListener('visibilitychange', ()=>{
    last = performance.now();
  });

  // initial zone text
  setZone(0);
  toast('Собирай крошки — очки идут только за них');
  toast('Двойной прыжок: второй — только в воздухе');
})();
</script>
</body>
</html>
